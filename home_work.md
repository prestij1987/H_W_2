


1. Задача на циклический итератор. Секция статьи "1. Задача на циклический итератор."
Надо написать класс CyclicIterator.
Итератор должен итерироваться по итерируемому объекту
(list, tuple, set, range, Range2, и т. д.), и когда достигнет последнего
элемента, начинать сначала.

cyclic_iterator = CyclicIterator(range(3))
for i in cyclic_iterator:
    print(i)

Скопировать
Основа:

class CyclicIterator:
    def __iter__(self):
        pass

    def __next__(self):
        pass

Скопировать
Для проверки. Ожидаемый вывод программы:

0
1
2
0


Скопировать
2. Задача на разжатие массива. Секция статьи "2. Задача на разжатие массива."
У каждого фильма есть расписание, по каким дням он идёт в кинотеатрах.
Для эффективности дни проката хранятся периодами дат. Например, прокат фильма
проходит с 1 по 7 января, а потом показ возобновляется
с 15 января по 7 февраля:

[
  (datetime(2020, 1, 1), datetime(2020, 1, 7)),
  (datetime(2020, 1, 15), datetime(2020, 2, 7))
]

Скопировать
Вам дан class Movie. Реализуйте у него метод schedule.
Он будет генерировать дни, в которые показывают фильм.

Основа:

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Generator, List, Tuple


@dataclass
class Movie:
    title: str
    dates: List[Tuple[datetime, datetime]]

    def schedule(self) -> Generator[datetime, None, None]:
        return []


m = Movie('sw', [
  (datetime(2020, 1, 1), datetime(2020, 1, 7)),
  (datetime(2020, 1, 15), datetime(2020, 2, 7))
])

for d in m.schedule():
    print(d)


1. Разработать программу для вычисления кратчайшего пути (https://github.com/mnv/python-basics).



2.Разработать игру «Обратные крестики-нолики» на поле 10 x 10 с правилом «Пять в ряд» – проигрывает тот, у кого получился вертикальный, горизонтальный или диагональный ряд из пяти своих фигур (крестиков/ноликов).

Игра должна работать в режиме «человек против компьютера».

Игра может быть консольной или поддерживать графический интерфейс (будет плюсом, но не требуется).

При разработке игры учесть принцип DRY (don’t repeat yourself) – «не повторяйся».   То есть минимизировать повторяемость кода и повысить его переиспользуемость   за счет использования функций. Функции должны иметь свою зону ответственности.




