# Разработать программу для вычисления кратчайшего пути для почтальона.
# Описание задачи
# Почтальон выходит из почтового отделения, объезжает всех адресатов один раз для вручения посылки и возвращается в почтовое отделение.
# Необходимо найти кратчайший маршрут для почтальона.
# Карта адресатов
# Карта адресов
# Координаты точек
# Почтовое отделение – (0, 2)
# Ул. Грибоедова, 104/25 – (2, 5)
# Ул. Бейкер стрит, 221б – (5, 2)
# Ул. Большая Садовая, 302-бис – (6, 6)
# Вечнозелёная Аллея, 742 – (8, 3)
# Описание решения
# Общее количество всех возможных путей проезда вычисляется по формуле (n - 1)!, где n – количество точек (адресатов).
# Расчёт количества возможных маршрутов объезда адресатов для данной карты: (5 - 1)! = 4! = 24 (маршрута). 
# Необходимо найти кратчайший маршрут и вывести последовательность точек, которые его составляют.
# Для поиска такого маршрута необходимо вычислять расстояния между точками, составляющих маршрут. Это позволит найти общую длину маршрута. 
# Путем перебора длин всех возможных маршрутов найти самый короткий из них.
# Расстояние между двумя точками на плоскости вычисляется по формуле: Расстояние между двумя точками
# Где x1 и y1 – координаты первой точки, x2 и y2 – координаты второй точки.
# Пример кода
# Вычисление расстояния между двумя точками на плоскости:
# point_1 = (0, 2)  # координаты первой точки
# point_2 = (2, 5)  # координаты второй точки
# # подстановка значений в формулу
# ((point_2[0] - point_1[0]) ** 2 + (point_2[1] - point_1[1]) ** 2) ** 0.5
# # результат – 3.605551275463989
# Требования к выходным данным
# Результат выполнения программы должен содержать последовательность точек, которые составляют самый короткий из маршрутов 
# с выводом промежуточных расстояний для каждой точки (от начала до текущей точки) и общей длины маршрута.

from itertools import permutations


class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y


def distance_ev(point_1, point_2):
    return ((point_2.x - point_1.x) ** 2 +
            (point_2.y - point_1.y) ** 2) ** 0.5


def find_shortest_path(start, points):
    combinations = permutations(points, len(points))
    result = [(start,) + comb + (start,) for comb in combinations]
    distances = []
    for path in result:
        distance = 0
        for i in range(1, len(path)):
            distance += distance_ev(path[i - 1], path[i])
        distances.append(distance)
    index = distances.index(min(distances))
    return result[index]


def result_to_print(points):
    distance = 0
    start = points[0]
    result = f'{start.x, start.y}'
    for i in range(1, len(points)):
        distance += distance_ev(points[i - 1], points[i])
        result += f' -> ({points[i].x}, {points[i].y})[{distance}] '
    result += f'= {distance}'
    return result


if __name__ == '__main__':
    points = [(0, 2), (2, 5), (5, 2), (6, 6), (8, 3)]
    start_point = Point(points[0][0], points[0][1])
    other_points = [Point(point[0], point[1]) for point in points[1:]]
    shortest_path = find_shortest_path(start_point, other_points)
    print(result_to_print(shortest_path))
